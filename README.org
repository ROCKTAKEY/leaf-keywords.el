#+author: conao
#+date: <2019-05-24 Fri>

[[https://github.com/conao3/leaf-keywords.el][https://raw.githubusercontent.com/conao3/files/master/blob/headers/png/leaf-keywords.el.png]]
[[https://github.com/conao3/leaf-keywords.el/blob/master/LICENSE][https://img.shields.io/github/license/conao3/leaf-keywords.el.svg?style=flat-square]]
[[https://github.com/conao3/leaf-keywords.el/releases][https://img.shields.io/github/tag/conao3/leaf-keywords.el.svg?style=flat-square]]
[[https://travis-ci.org/conao3/leaf-keywords.el][https://img.shields.io/travis/conao3/leaf-keywords.el/master.svg?style=flat-square]]
[[https://app.codacy.com/project/conao3/leaf-keywords.el/dashboard][https://img.shields.io/codacy/grade/1a6befcbdfdb4b1fb37a6f7f040a75b2.svg?logo=codacy&style=flat-square]]
[[https://www.patreon.com/conao3][https://img.shields.io/badge/patreon-@conao3-orange.svg?logo=patreon&style=flat-square]]
[[https://twitter.com/conao_3][https://img.shields.io/badge/twitter-@conao__3-blue.svg?logo=twitter&style=flat-square]]
[[https://join.slack.com/t/conao3-support/shared_invite/enQtNTg2MTY0MjkzOTU0LTFjOTdhOTFiNTM2NmY5YTE5MTNlYzNiOTE2MTZlZWZkNDEzZmRhN2E0NjkwMWViZTZiYjA4MDUxYTUzNDZiNjY][https://img.shields.io/badge/chat-on_slack-blue.svg?logo=slack&style=flat-square]]

* Table of Contents
- [[#description][Description]]
- [[#install][Install]]
  - [[#el-get-install][El-get install]]
  - [[#manual-install][Manual install]]
- [[#usage][Usage]]
- [[#ensure-keywords][Ensure keywords]]
  - [[#package-ensure-keywords][:package, :ensure keywords]]
  - [[#el-get-keyword][:el-get keyword]]
- [[#bind-keywords][Bind keywords]]
  - [[#bind-bind-keywords][:bind :bind* keywords]]
  - [[#chord-chord-keywords][:chord :chord* keywords]]
  - [[#smartrep-smartrep-keywords][:smartrep :smartrep* keywords]]
  - [[#combo-combo-keywords][:combo, :combo* keywords]]
  - [[#hydra-keyword][:hydra keyword]]
- [[#modeline-keywords][Modeline keywords]]
  - [[#diminish-keyword][:diminish keyword]]
  - [[#delight-keyword][:delight keyword]]
- [[#information][Information]]
  - [[#donation][Donation]]
  - [[#community][Community]]
  - [[#contribution][Contribution]]
    - [[#define-new-keywords][Define new keywords]]
  - [[#migration][Migration]]
  - [[#license][License]]
  - [[#author][Author]]
  - [[#contributors][Contributors]]
  - [[#special-thanks][Special Thanks]]

* Description
~leaf.el~ is yet another [[https://github.com/jwiegley/use-package][use-package]].

~leaf-keywords.el~ add additional keywords for [[https://github.com/conao3/leaf.el][leaf.el]].

* Install
~leaf.el~ and ~leaf-keywords.el~ are not part of MELPA. So you need to download it.

** El-get install
#+begin_src emacs-lisp
  (prog1 "Load leaf.el"
    ;; this code is expansion form of `(leaf el-get :ensure t)'
    (unless
        (package-installed-p 'el-get)
      (condition-case err
          (progn
            (unless
                (assoc 'el-get package-archive-contents)
              (package-refresh-contents))
            (package-install 'el-get))
        (error
         (condition-case err
             (progn
               (package-refresh-contents)
               (package-install 'el-get))
           (error
            (leaf-error "In `el-get' block, failed to :package of el-get.  Error msg: %s"
                        (error-message-string err)))))))
    (require 'el-get)

    (el-get-bundle! leaf in conao3/leaf.el)
    (leaf leaf
      :doc "Symplify your init.el configuration"
      :doc "Initialize leaf dependent packages"
      :config
      (leaf package
        :custom ((package-archives . '(("org"   . "https://orgmode.org/elpa/")
                                       ("melpa" . "https://melpa.org/packages/")
                                       ("gnu"   . "https://elpa.gnu.org/packages/"))))
        :config
        (package-initialize))
      (leaf leaf-keywords
        :require t
        :el-get (leaf-keywords in conao3/leaf-keywords.el)
        :config (leaf-keywords-init))))
#+end_src

** Manual instlal
Put ~leaf-keywords.el~ at any folder added ~load-path~.
Then ~(require 'leaf-keywords)~.

#+BEGIN_SRC emacs-lisp
    ;; add to load-path
    ;; (locate-user-emacs-file "site-lisp/leaf-keywords.el")
    ;;  => "~/.emacs.d/local/26.1/site-lisp/leaf-keywords.el"

    (prog1 "Load leaf.el"
      (add-to-list 'load-path (locate-user-emacs-file "site-lisp/leaf.el"))
      (require 'leaf)
      (leaf leaf
        :doc "Symplify your init.el configuration"
        :doc "Initialize leaf dependent packages"
        :config
        (leaf package
          :custom ((package-archives . '(("org"   . "https://orgmode.org/elpa/")
                                         ("melpa" . "https://melpa.org/packages/")
                                         ("gnu"   . "https://elpa.gnu.org/packages/"))))
          :config (package-initialize))))

    (leaf leaf-keywords
          :load-path `,(locate-user-emacs-file "site-lisp/leaf-keywords.el")
          :require t
          :config (leaf-keywords-init))
#+END_SRC

* Usage
Use ~leaf~ in your init.el like ~use-package~.
You declaratively tell the ~leaf~ to configure the package using special keywords.

~leaf~ converts your declaration into Elisp for Emacs to understand, and Emacs executes it to configure the package.

* Ensure keywords
** :package, :ensure keywords
These keywords are buildin. Info is [[https://github.com/conao3/leaf.el#package-ensure-keywords][here]].

#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/package
    '(((leaf leaf
         :package t
         :config (leaf-init))
       (prog1 'leaf
         (leaf-handler-package leaf leaf nil)
         (leaf-init)))

      ((leaf leaf
         :package t leaf-browser
         :config (leaf-init))
       (prog1 'leaf
         (leaf-handler-package leaf leaf nil)
         (leaf-handler-package leaf leaf-browser nil)
         (leaf-init)))

      ((leaf leaf
         :package feather leaf-key leaf-browser
         :config (leaf-init))
       (prog1 'leaf
         (leaf-handler-package leaf feather nil)
         (leaf-handler-package leaf leaf-key nil)
         (leaf-handler-package leaf leaf-browser nil)
         (leaf-init)))))

  (cort-deftest-with-macroexpand leaf/handler-package
    '(((leaf macrostep :ensure t)
       (prog1 'macrostep
         (leaf-handler-package macrostep macrostep nil))

       ((leaf-handler-package macrostep macrostep nil)
        (unless
            (package-installed-p 'macrostep)
          (condition-case err
              (progn
                (unless (assoc 'macrostep package-archive-contents)
                  (package-refresh-contents))
                (package-install 'macrostep))
            (error
             (condition-case err
                 (progn
                   (package-refresh-contents)
                   (package-install 'macrostep))
               (error
                (leaf-error "In `macrostep' block, failed to :package of macrostep.  Error msg: %s"
                            (error-message-string err)))))))))))
#+end_src

** :el-get keyword
~:el-get~ provide frontend of ~el-get-bundle~.

If you specify ~t~, leaf assumes that you specified the name of the leaf-block.

Given a list, the arguments are passed as is to the ~el-get-bundle~.

#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/el-get
    '(((leaf leaf
         :init (leaf-pre-init)
         :el-get t
         :config (leaf-init))
       (prog1 'leaf
         (eval-after-load 'el-get
           '(progn
              (el-get-bundle leaf)))
         (leaf-pre-init)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :el-get leaf leaf-polyfill
         :config (leaf-init))
       (prog1 'leaf
         (eval-after-load 'el-get
           '(progn
              (el-get-bundle leaf)
              (el-get-bundle leaf-polyfill)))
         (leaf-pre-init)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :el-get t
         :el-get leaf-polyfill
         :config (leaf-init))
       (prog1 'leaf
         (eval-after-load 'el-get
           '(progn
              (el-get-bundle leaf)
              (el-get-bundle leaf-polyfill)))
         (leaf-pre-init)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :el-get t leaf-polyfill
         :config (leaf-init))
       (prog1 'leaf
         (eval-after-load 'el-get
           '(progn
              (el-get-bundle leaf)
              (el-get-bundle leaf-polyfill)))
         (leaf-pre-init)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :el-get (zenburn-theme
                  :url "https://raw.githubusercontent.com/bbatsov/zenburn-emacs/master/zenburn-theme.el"
                  (load-theme 'zenburn t))
         :config (leaf-init))
       (prog1 'leaf
         (eval-after-load 'el-get
           '(progn
              (el-get-bundle zenburn-theme :url "https://raw.githubusercontent.com/bbatsov/zenburn-emacs/master/zenburn-theme.el"
                (load-theme 'zenburn t))))
         (leaf-pre-init)
         (leaf-init)))

      ((leaf leaf
         :init (leaf-pre-init)
         :el-get
         (yaicomplete
          :url "https://github.com/tarao/elisp.git"
          :features yaicomplete)
         (zenburn-theme
          :url "https://raw.githubusercontent.com/bbatsov/zenburn-emacs/master/zenburn-theme.el"
          (load-theme 'zenburn t))
         (kazu-yamamoto/Mew :name mew :build ("./configure" "make"))
         :config (leaf-init))
       (prog1 'leaf
         (eval-after-load 'el-get
           '(progn
              (el-get-bundle yaicomplete :url "https://github.com/tarao/elisp.git" :features yaicomplete)
              (el-get-bundle zenburn-theme :url "https://raw.githubusercontent.com/bbatsov/zenburn-emacs/master/zenburn-theme.el"
                (load-theme 'zenburn t))
              (el-get-bundle kazu-yamamoto/Mew :name mew :build ("./configure" "make"))))
         (leaf-pre-init)
         (leaf-init)))))
#+end_src

* Bind keywords
** :bind :bind* keywords
These keywords are buildin. Info is [[https://github.com/conao3/leaf.el#bind-bind-keywords][here]].

#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/bind
    '(((leaf macrostep
         :package t
         :bind (("C-c e" . macrostep-expand)))
       (prog1 'macrostep
         (autoload #'macrostep-expand "macrostep" nil t)
         (leaf-handler-package macrostep macrostep nil)
         (leaf-keys (("C-c e" . macrostep-expand)))))

      ((leaf macrostep
         :package t
         :bind ("C-c e" . macrostep-expand))
       (prog1 'macrostep
         (autoload #'macrostep-expand "macrostep" nil t)
         (leaf-handler-package macrostep macrostep nil)
         (leaf-keys
          (("C-c e" . macrostep-expand)))))

      ((leaf color-moccur
         :bind
         ("M-s O" . moccur)
         ("M-o" . isearch-moccur)
         ("M-O" . isearch-moccur-all))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (leaf-keys (("M-s O" . moccur)
                     ("M-o" . isearch-moccur)
                     ("M-O" . isearch-moccur-all)))))

      ((leaf color-moccur
         :bind (("M-s O" . moccur)
                ("M-o" . isearch-moccur)
                ("M-O" . isearch-moccur-all)))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (leaf-keys (("M-s O" . moccur)
                     ("M-o" . isearch-moccur)
                     ("M-O" . isearch-moccur-all)))))

      ((leaf color-moccur
         :bind
         ("M-s" . nil)
         ("M-s o" . isearch-moccur)
         ("M-s i" . isearch-moccur-all))
       (prog1 'color-moccur
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (leaf-keys (("M-s")
                     ("M-s o" . isearch-moccur)
                     ("M-s i" . isearch-moccur-all)))))

      ((leaf color-moccur
         :bind (("M-s" . nil)
                ("M-s o" . isearch-moccur)
                ("M-s i" . isearch-moccur-all)))
       (prog1 'color-moccur
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (leaf-keys (("M-s")
                     ("M-s o" . isearch-moccur)
                     ("M-s i" . isearch-moccur-all)))))

      ((leaf color-moccur
         :bind
         ("M-s O" . moccur)
         (:isearch-mode-map
          ("M-o" . isearch-moccur)
          ("M-O" . isearch-moccur-all)))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (leaf-keys (("M-s O" . moccur)
                     (:isearch-mode-map
                      :package color-moccur
                      ("M-o" . isearch-moccur)
                      ("M-O" . isearch-moccur-all))))))

      ((leaf color-moccur
         :bind
         ("M-s O" . moccur)
         (:isearch-mode-map
          :package isearch
          ("M-o" . isearch-moccur)
          ("M-O" . isearch-moccur-all)))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (leaf-keys (("M-s O" . moccur)
                     (:isearch-mode-map
                      :package isearch
                      ("M-o" . isearch-moccur)
                      ("M-O" . isearch-moccur-all))))))

      ((leaf color-moccur
         :bind (("M-s O" . moccur)
                (:isearch-mode-map
                 :package isearch
                 ("M-o" . isearch-moccur)
                 ("M-O" . isearch-moccur-all))))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (leaf-keys (("M-s O" . moccur)
                     (:isearch-mode-map
                      :package isearch
                      ("M-o" . isearch-moccur)
                      ("M-O" . isearch-moccur-all))))))

      ;; you also use symbol instead of keyword to specify keymap
      ((leaf color-moccur
         :bind (("M-s O" . moccur)
                (isearch-mode-map
                 :package isearch
                 ("M-o" . isearch-moccur)
                 ("M-O" . isearch-moccur-all))))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (leaf-keys (("M-s O" . moccur)
                     (isearch-mode-map
                      :package isearch
                      ("M-o" . isearch-moccur)
                      ("M-O" . isearch-moccur-all))))))))

  (cort-deftest-with-macroexpand leaf/leaf-key
    '(((leaf-key "C-M-i" 'flyspell-correct-wrapper)
       (let* ((old (lookup-key global-map (kbd "C-M-i")))
              (value `(("C-M-i" . global-map) flyspell-correct-wrapper ,(and old (not (numberp old)) old))))
         (push value leaf-key-bindlist)
         (define-key global-map (kbd "C-M-i") 'flyspell-correct-wrapper)))))
#+end_src

** :chord :chord* keywords
~:chord~ and ~:chord*~ provide frontend for ~leaf-key-chord~ which bind key for [[https://github.com/emacsorphanage/key-chord][key-chord]].

The usage and notes are the same as for the ~:bind~ keyword.

#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/chord
    '(((leaf macrostep
         :ensure t
         :chord (("jk" . macrostep-expand)))
       (prog1 'macrostep
         (autoload #'macrostep-expand "macrostep" nil t)
         (leaf-handler-package macrostep macrostep nil)
         (eval-after-load 'key-chord
           '(progn
              (leaf-key-chords
               (("jk" . macrostep-expand)))))))

      ((leaf macrostep
         :ensure t
         :chord ("jk" . macrostep-expand))
       (prog1 'macrostep
         (autoload #'macrostep-expand "macrostep" nil t)
         (leaf-handler-package macrostep macrostep nil)
         (eval-after-load 'key-chord
           '(progn
              (leaf-key-chords
               (("jk" . macrostep-expand)))))))

      ((leaf color-moccur
         :chord
         ("jk" . moccur)
         ("fi" . isearch-moccur))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (eval-after-load 'key-chord
           '(progn
              (leaf-key-chords
               (("jk" . moccur)
                ("fi" . isearch-moccur)))))))

      ((leaf color-moccur
         :chord (("jk" . moccur)
                 ("fi" . isearch-moccur)))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (eval-after-load 'key-chord
           '(progn
              (leaf-key-chords
               (("jk" . moccur)
                ("fi" . isearch-moccur)))))))

      ((leaf color-moccur
         :chord
         ("jk" . nil)
         ("fi" . isearch-moccur))
       (prog1 'color-moccur
         (autoload #'isearch-moccur "color-moccur" nil t)
         (eval-after-load 'key-chord
           '(progn
              (leaf-key-chords
               (("jk")
                ("fi" . isearch-moccur)))))))

      ((leaf color-moccur
         :chord (("jk" . nil)
                 ("fi" . isearch-moccur)))
       (prog1 'color-moccur
         (autoload #'isearch-moccur "color-moccur" nil t)
         (eval-after-load 'key-chord
           '(progn
              (leaf-key-chords
               (("jk")
                ("fi" . isearch-moccur)))))))

      ((leaf color-moccur
         :chord
         ("jk" . moccur)
         (:isearch-mode-map
          :package isearch
          ("ji" . isearch-moccur)
          ("jo" . isearch-moccur-all)))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (eval-after-load 'key-chord
           '(progn
              (leaf-key-chords
               (("jk" . moccur)
                (:isearch-mode-map
                 :package isearch
                 ("ji" . isearch-moccur)
                 ("jo" . isearch-moccur-all))))))))

      ((leaf color-moccur
         :chord (("jk" . moccur)
                 (:isearch-mode-map
                  :package isearch
                  ("ji" . isearch-moccur)
                  ("jo" . isearch-moccur-all))))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (eval-after-load 'key-chord
           '(progn
              (leaf-key-chords
               (("jk" . moccur)
                (:isearch-mode-map
                 :package isearch
                 ("ji" . isearch-moccur)
                 ("jo" . isearch-moccur-all))))))))

      ;; you also use symbol instead of keyword to specify keymap
      ((leaf color-moccur
         :chord (("jk" . moccur)
                 (isearch-mode-map
                  :package isearch
                  ("ji" . isearch-moccur)
                  ("jo" . isearch-moccur-all))))
       (prog1 'color-moccur
         (autoload #'moccur "color-moccur" nil t)
         (autoload #'isearch-moccur "color-moccur" nil t)
         (autoload #'isearch-moccur-all "color-moccur" nil t)
         (eval-after-load 'key-chord
           '(progn
              (leaf-key-chords
               (("jk" . moccur)
                (isearch-mode-map
                 :package isearch
                 ("ji" . isearch-moccur)
                 ("jo" . isearch-moccur-all))))))))))

  (cort-deftest-with-macroexpand leaf/leaf-key-chord
    '(((leaf-key-chord "jj" 'undo 'c-mode-map)
       (leaf-key [key-chord 106 106] 'undo 'c-mode-map))

      ((leaf-key-chord "jk" 'undo 'c-mode-map)
       (progn
         (leaf-key [key-chord 106 107] 'undo 'c-mode-map)
         (leaf-key [key-chord 107 106] 'undo 'c-mode-map)))

      ((leaf-key-chord "jj" 'undo)
       (leaf-key [key-chord 106 106] 'undo nil))

      ((leaf-key-chord "jk" 'undo)
       (progn
         (leaf-key [key-chord 106 107] 'undo nil)
         (leaf-key [key-chord 107 106] 'undo nil)))))
#+end_src

** :smartrep, :smartrep* keywords
~:smartrep~ and ~:smartrep*~ provide frontend for [[https://github.com/myuhe/smartrep.el][smartrep]].

They can process a list of arguments that the ~smartrep~ accepts, or a nested list of them.

Automatically generates an ~autoload~ statement when a function symbol is passed.

Quoting a function or quoting a binding list works the same way.

If you omit the key-map to bind, use ~global-map~ instead in ~:smartrep~ and
~leaf-key-override-global-map~ for leaf-key in ~:smartrep*~.

#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/smartrep
    '(((leaf multiple-cursors
         :smartrep ("C-t"
                    (("C-p" . mc/mark-previous-like-this)
                     ("C-n" . mc/mark-next-like-this)
                     ("u"   . mc/unmark-next-like-this)
                     ("U"   . mc/unmark-previous-like-this)
                     ("s"   . mc/skip-to-next-like-this)
                     ("S"   . mc/skip-to-previous-like-this)
                     ("*"   . mc/mark-all-like-this))))
       (prog1 'multiple-cursors
         (autoload #'mc/mark-previous-like-this "multiple-cursors" nil t)
         (autoload #'mc/mark-next-like-this "multiple-cursors" nil t)
         (autoload #'mc/unmark-next-like-this "multiple-cursors" nil t)
         (autoload #'mc/unmark-previous-like-this "multiple-cursors" nil t)
         (autoload #'mc/skip-to-next-like-this "multiple-cursors" nil t)
         (autoload #'mc/skip-to-previous-like-this "multiple-cursors" nil t)
         (autoload #'mc/mark-all-like-this "multiple-cursors" nil t)
         (eval-after-load 'smartrep
           '(progn
              (smartrep-define-key global-map "C-t"
                '(("C-p" . mc/mark-previous-like-this)
                  ("C-n" . mc/mark-next-like-this)
                  ("u" . mc/unmark-next-like-this)
                  ("U" . mc/unmark-previous-like-this)
                  ("s" . mc/skip-to-next-like-this)
                  ("S" . mc/skip-to-previous-like-this)
                  ("*" . mc/mark-all-like-this)))))))

      ((leaf multiple-cursors
         :smartrep (global-map
                    "C-t"
                    (("C-p" . mc/mark-previous-like-this)
                     ("C-n" . mc/mark-next-like-this))))
       (prog1 'multiple-cursors
         (autoload #'mc/mark-previous-like-this "multiple-cursors" nil t)
         (autoload #'mc/mark-next-like-this "multiple-cursors" nil t)
         (eval-after-load 'smartrep
           '(progn
              (smartrep-define-key global-map "C-t"
                '(("C-p" . mc/mark-previous-like-this)
                  ("C-n" . mc/mark-next-like-this)))))))

      ((leaf multiple-cursors
         :smartrep (global-map
                    "C-t"
                    (("C-p" . 'mc/mark-previous-like-this)
                     ("C-n" . 'mc/mark-next-like-this))))
       (prog1 'multiple-cursors
         (autoload #'mc/mark-previous-like-this "multiple-cursors" nil t)
         (autoload #'mc/mark-next-like-this "multiple-cursors" nil t)
         (eval-after-load 'smartrep
           '(progn
              (smartrep-define-key global-map "C-t"
                '(("C-p" quote mc/mark-previous-like-this)
                  ("C-n" quote mc/mark-next-like-this)))))))

      ((leaf multiple-cursors
         :smartrep (global-map
                    "C-t"
                    '(("C-p" . 'mc/mark-previous-like-this)
                      ("C-n" . 'mc/mark-next-like-this))))
       (prog1 'multiple-cursors
         (autoload #'mc/mark-previous-like-this "multiple-cursors" nil t)
         (autoload #'mc/mark-next-like-this "multiple-cursors" nil t)
         (eval-after-load 'smartrep
           '(progn
              (smartrep-define-key global-map "C-t"
                '(("C-p" quote mc/mark-previous-like-this)
                  ("C-n" quote mc/mark-next-like-this)))))))

      ((leaf org
         :smartrep (org-mode-map
                    "C-c"
                    (("C-n" . (outline-next-visible-heading 1))
                     ("C-p" . (outline-previous-visible-heading 1)))))
       (prog1 'org
         (eval-after-load 'smartrep
           '(progn
              (smartrep-define-key org-mode-map "C-c"
                '(("C-n" outline-next-visible-heading 1)
                  ("C-p" outline-previous-visible-heading 1)))))))

      ((leaf org
         :smartrep ((org-mode-map
                     "C-c"
                     (("C-n" . (outline-next-visible-heading 1))
                      ("C-p" . (outline-previous-visible-heading 1))))
                    ("s-c"
                     (("M-n" . (outline-next-visible-heading 1))
                      ("M-p" . (outline-previous-visible-heading 1))))))
       (prog1 'org
         (eval-after-load 'smartrep
           '(progn
              (smartrep-define-key org-mode-map "C-c"
                '(("C-n" outline-next-visible-heading 1)
                  ("C-p" outline-previous-visible-heading 1)))
              (smartrep-define-key global-map "s-c"
                '(("M-n" outline-next-visible-heading 1)
                  ("M-p" outline-previous-visible-heading 1)))))))))

  (cort-deftest-with-macroexpand leaf/smartrep*
    '(((leaf multiple-cursors
         :smartrep* ("C-t"
                     (("C-p" . mc/mark-previous-like-this)
                      ("C-n" . mc/mark-next-like-this)
                      ("u"   . mc/unmark-next-like-this)
                      ("U"   . mc/unmark-previous-like-this)
                      ("s"   . mc/skip-to-next-like-this)
                      ("S"   . mc/skip-to-previous-like-this)
                      ("*"   . mc/mark-all-like-this))))
       (prog1 'multiple-cursors
         (autoload #'mc/mark-previous-like-this "multiple-cursors" nil t)
         (autoload #'mc/mark-next-like-this "multiple-cursors" nil t)
         (autoload #'mc/unmark-next-like-this "multiple-cursors" nil t)
         (autoload #'mc/unmark-previous-like-this "multiple-cursors" nil t)
         (autoload #'mc/skip-to-next-like-this "multiple-cursors" nil t)
         (autoload #'mc/skip-to-previous-like-this "multiple-cursors" nil t)
         (autoload #'mc/mark-all-like-this "multiple-cursors" nil t)
         (eval-after-load 'smartrep
           '(progn
              (smartrep-define-key leaf-key-override-global-map "C-t"
                '(("C-p" . mc/mark-previous-like-this)
                  ("C-n" . mc/mark-next-like-this)
                  ("u" . mc/unmark-next-like-this)
                  ("U" . mc/unmark-previous-like-this)
                  ("s" . mc/skip-to-next-like-this)
                  ("S" . mc/skip-to-previous-like-this)
                  ("*" . mc/mark-all-like-this)))))))

      ((leaf org
         :smartrep* ((org-mode-map
                      "C-c"
                      (("C-n" . (outline-next-visible-heading 1))
                       ("C-p" . (outline-previous-visible-heading 1))))
                     ("s-c"
                      (("M-n" . (outline-next-visible-heading 1))
                       ("M-p" . (outline-previous-visible-heading 1))))))
       (prog1 'org
         (eval-after-load 'smartrep
           '(progn
              (smartrep-define-key org-mode-map "C-c"
                '(("C-n" outline-next-visible-heading 1)
                  ("C-p" outline-previous-visible-heading 1)))
              (smartrep-define-key leaf-key-override-global-map "s-c"
                '(("M-n" outline-next-visible-heading 1)
                  ("M-p" outline-previous-visible-heading 1)))))))))
#+end_src

** :combo, :combo* keywords
~:combo~, ~:combo*~ provide frontend for [[https://github.com/uk-ar/key-combo][key-combo]].

They can process a list of arguments, or a nested list of them.

Automatically generates an ~autoload~ statement when a function symbol is passed.

If you omit the key-map to bind, use ~global-map~ instead in ~:combo~ and
~leaf-key-override-global-map~ for leaf-key in ~:combo*~.

#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/key-combo
    '(((leaf key-combo
         :combo (("="   . (" = " " == " " === " ))
                 ("=>"  . " => ")
                 ("C-a" . (back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
                 ("C-e" . (move-end-of-line end-of-buffer key-combo-return))))
       (prog1 'key-combo
         (autoload #'back-to-indentation "key-combo" nil t)
         (autoload #'move-beginning-of-line "key-combo" nil t)
         (autoload #'beginning-of-buffer "key-combo" nil t)
         (autoload #'key-combo-return "key-combo" nil t)
         (autoload #'move-end-of-line "key-combo" nil t)
         (autoload #'end-of-buffer "key-combo" nil t)
         (eval-after-load 'key-combo
           '(progn
              (key-combo-define global-map "=>" " => ")
              (key-combo-define global-map "C-a" '(back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
              (key-combo-define global-map "C-e" '(move-end-of-line end-of-buffer key-combo-return))))))

      ((leaf key-combo
         :combo (emacs-lisp-mode-map
                 ("="   . (" = " " == " " === " ))
                 ("=>"  . " => ")
                 ("C-a" . (back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
                 ("C-e" . (move-end-of-line end-of-buffer key-combo-return))))
       (prog1 'key-combo
         (autoload #'back-to-indentation "key-combo" nil t)
         (autoload #'move-beginning-of-line "key-combo" nil t)
         (autoload #'beginning-of-buffer "key-combo" nil t)
         (autoload #'key-combo-return "key-combo" nil t)
         (autoload #'move-end-of-line "key-combo" nil t)
         (autoload #'end-of-buffer "key-combo" nil t)
         (eval-after-load 'key-combo
           '(progn
              (key-combo-define emacs-lisp-mode-map "=" '(" = " " == " " === "))
              (key-combo-define emacs-lisp-mode-map "=>" " => ")
              (key-combo-define emacs-lisp-mode-map "C-a" '(back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
              (key-combo-define emacs-lisp-mode-map "C-e" '(move-end-of-line end-of-buffer key-combo-return))))))

      ((leaf key-combo
         :combo ((("="   . (" = " " == " " === " ))
                  ("=>"  . " => ")
                  ("C-a" . (back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
                  ("C-e" . (move-end-of-line end-of-buffer key-combo-return)))
                 (emacs-lisp-mode-map
                  ("."  . ("." " . "))
                  ("="  . ("= " "eq " "equal ")))))
       (prog1 'key-combo
         (autoload #'back-to-indentation "key-combo" nil t)
         (autoload #'move-beginning-of-line "key-combo" nil t)
         (autoload #'beginning-of-buffer "key-combo" nil t)
         (autoload #'key-combo-return "key-combo" nil t)
         (autoload #'move-end-of-line "key-combo" nil t)
         (autoload #'end-of-buffer "key-combo" nil t)
         (eval-after-load 'key-combo
           '(progn
              (key-combo-define global-map "=>" " => ")
              (key-combo-define global-map "C-a" '(back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
              (key-combo-define global-map "C-e" '(move-end-of-line end-of-buffer key-combo-return))
              (key-combo-define emacs-lisp-mode-map "." '("." " . "))
              (key-combo-define emacs-lisp-mode-map "=" '("= " "eq " "equal "))))))))

  (cort-deftest-with-macroexpand leaf/key-combo*
    '(((leaf key-combo
         :combo* (("="   . (" = " " == " " === " ))
                  ("=>"  . " => ")
                  ("C-a" . (back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
                  ("C-e" . (move-end-of-line end-of-buffer key-combo-return))))
       (prog1 'key-combo
         (autoload #'back-to-indentation "key-combo" nil t)
         (autoload #'move-beginning-of-line "key-combo" nil t)
         (autoload #'beginning-of-buffer "key-combo" nil t)
         (autoload #'key-combo-return "key-combo" nil t)
         (autoload #'move-end-of-line "key-combo" nil t)
         (autoload #'end-of-buffer "key-combo" nil t)
         (eval-after-load 'key-combo
           '(progn
              (key-combo-define leaf-key-override-global-map "=>" " => ")
              (key-combo-define leaf-key-override-global-map "C-a" '(back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
              (key-combo-define leaf-key-override-global-map "C-e" '(move-end-of-line end-of-buffer key-combo-return))))))

      ((leaf key-combo
         :combo* (emacs-lisp-mode-map
                  ("="   . (" = " " == " " === " ))
                  ("=>"  . " => ")
                  ("C-a" . (back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
                  ("C-e" . (move-end-of-line end-of-buffer key-combo-return))))
       (prog1 'key-combo
         (autoload #'back-to-indentation "key-combo" nil t)
         (autoload #'move-beginning-of-line "key-combo" nil t)
         (autoload #'beginning-of-buffer "key-combo" nil t)
         (autoload #'key-combo-return "key-combo" nil t)
         (autoload #'move-end-of-line "key-combo" nil t)
         (autoload #'end-of-buffer "key-combo" nil t)
         (eval-after-load 'key-combo
           '(progn
              (key-combo-define emacs-lisp-mode-map "=" '(" = " " == " " === "))
              (key-combo-define emacs-lisp-mode-map "=>" " => ")
              (key-combo-define emacs-lisp-mode-map "C-a" '(back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
              (key-combo-define emacs-lisp-mode-map "C-e" '(move-end-of-line end-of-buffer key-combo-return))))))

      ((leaf key-combo
         :combo* ((("="   . (" = " " == " " === " ))
                   ("=>"  . " => ")
                   ("C-a" . (back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
                   ("C-e" . (move-end-of-line end-of-buffer key-combo-return)))
                  (emacs-lisp-mode-map
                   ("."  . ("." " . "))
                   ("="  . ("= " "eq " "equal ")))))
       (prog1 'key-combo
         (autoload #'back-to-indentation "key-combo" nil t)
         (autoload #'move-beginning-of-line "key-combo" nil t)
         (autoload #'beginning-of-buffer "key-combo" nil t)
         (autoload #'key-combo-return "key-combo" nil t)
         (autoload #'move-end-of-line "key-combo" nil t)
         (autoload #'end-of-buffer "key-combo" nil t)
         (eval-after-load 'key-combo
           '(progn
              (key-combo-define leaf-key-override-global-map "=>" " => ")
              (key-combo-define leaf-key-override-global-map "C-a" '(back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
              (key-combo-define leaf-key-override-global-map "C-e" '(move-end-of-line end-of-buffer key-combo-return))
              (key-combo-define emacs-lisp-mode-map "." '("." " . "))
              (key-combo-define emacs-lisp-mode-map "=" '("= " "eq " "equal "))))))))
#+end_src

** :hydra keyword
~:hydra~ provide frontend for [[https://github.com/abo-abo/hydra][hydra]].

If you pass a list, you pass it to ~defhydra~, and if you pass a nested list, you pass each one to it.

The reason for using this keyword is that it automatically creates an ~autoload~ statement.

#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/hydra
    '(((leaf face-remap
         :hydra (hydra-zoom
                 (global-map "<f2>")
                 "zoom"
                 ("g" text-scale-increase "in")
                 ("l" text-scale-decrease "out")))
       (prog1 'face-remap
         (autoload #'text-scale-increase "face-remap" nil t)
         (autoload #'text-scale-decrease "face-remap" nil t)
         (eval-after-load 'hydra
           '(progn
              (defhydra hydra-zoom
                (global-map "<f2>")
                "zoom"
                ("g" text-scale-increase "in")
                ("l" text-scale-decrease "out"))))))

      ((leaf yasnippet
         :bind (:yas-minor-mode-map
                ("<f3>" . hydra-yas-primary/body)
                ("<f2>" . hydra-yas/body))
         :hydra ((hydra-yas-primary
                  (:hint nil)
                  "yas-primary"
                  ("i" yas-insert-snippet)
                  ("n" yas-new-snippet)
                  ("v" yas-visit-snippet-file))
                 (hydra-yas
                  (:color blue :hint nil)
                  "
                ^YASnippets^
  --------------------------------------------
    Modes:    Load/Visit:    Actions:

   _g_lobal  _d_irectory    _i_nsert
   _m_inor   _f_ile         _t_ryout
   _e_xtra   _l_ist         _n_ew
           _a_ll
  "
                  ("d" yas-load-directory)
                  ("e" yas-activate-extra-mode)
                  ("i" yas-insert-snippet)
                  ("f" yas-visit-snippet-file :color blue)
                  ("n" yas-new-snippet)
                  ("t" yas-tryout-snippet)
                  ("l" yas-describe-tables)
                  ("g" yas/global-mode)
                  ("m" yas/minor-mode)
                  ("a" yas-reload-all))))
       (prog1 'yasnippet
         (autoload #'yas-insert-snippet "yasnippet" nil t)
         (autoload #'yas-new-snippet "yasnippet" nil t)
         (autoload #'yas-visit-snippet-file "yasnippet" nil t)
         (autoload #'yas-load-directory "yasnippet" nil t)
         (autoload #'yas-activate-extra-mode "yasnippet" nil t)
         (autoload #'yas-tryout-snippet "yasnippet" nil t)
         (autoload #'yas-describe-tables "yasnippet" nil t)
         (autoload #'yas/global-mode "yasnippet" nil t)
         (autoload #'yas/minor-mode "yasnippet" nil t)
         (autoload #'yas-reload-all "yasnippet" nil t)
         (autoload #'hydra-yas-primary/body "yasnippet" nil t)
         (autoload #'hydra-yas/body "yasnippet" nil t)
         (leaf-keys
          ((:yas-minor-mode-map :package yasnippet
                                ("<f3>" . hydra-yas-primary/body)
                                ("<f2>" . hydra-yas/body))))
         (eval-after-load 'hydra
           '(progn
              (defhydra hydra-yas-primary
                (:hint nil)
                "yas-primary"
                ("i" yas-insert-snippet)
                ("n" yas-new-snippet)
                ("v" yas-visit-snippet-file))
              (defhydra hydra-yas
                (:color blue :hint nil)
                "
                ^YASnippets^
  --------------------------------------------
    Modes:    Load/Visit:    Actions:

   _g_lobal  _d_irectory    _i_nsert
   _m_inor   _f_ile         _t_ryout
   _e_xtra   _l_ist         _n_ew
           _a_ll
  "
                ("d" yas-load-directory)
                ("e" yas-activate-extra-mode)
                ("i" yas-insert-snippet)
                ("f" yas-visit-snippet-file :color blue)
                ("n" yas-new-snippet)
                ("t" yas-tryout-snippet)
                ("l" yas-describe-tables)
                ("g" yas/global-mode)
                ("m" yas/minor-mode)
                ("a" yas-reload-all))))))))
#+end_src

* Modeline keywords
** :diminish keyword
~:diminish~ keyword provide frontend for [[https://github.com/myrjola/diminish.el/tree/master][diminish]].

#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/diminish
    '(((leaf autorevert
         :diminish t)
       (prog1 'autorevert
         (eval-after-load 'diminish
           '(progn
              (diminish autorevert)))))

      ((leaf autorevert
         :diminish autorevert)
       (prog1 'autorevert
         (eval-after-load 'diminish
           '(progn
              (diminish autorevert)))))

      ((leaf autorevert
         :diminish t
         :diminish autorevert-polyfill)
       (prog1 'autorevert
         (eval-after-load 'diminish
           '(progn
              (diminish autorevert)
              (diminish autorevert-polyfill)))))

      ((leaf autorevert
         :diminish t autorevert-polyfill)
       (prog1 'autorevert
         (eval-after-load 'diminish
           '(progn
              (diminish autorevert)
              (diminish autorevert-polyfill)))))

      ((leaf go-mode
         :diminish " Go")
       (prog1 'go-mode
         (eval-after-load 'diminish
           '(progn
              (diminish go-mode " Go")))))

      ((leaf abbrev
         :diminish (abbrev-mode " Abv"))
       (prog1 'abbrev
         (eval-after-load 'diminish
           '(progn
              (diminish abbrev-mode " Abv")))))

      ((leaf projectile
         :diminish (projectile (:eval (concat " " (projectile-project-name)))))
       (prog1 'projectile
         (eval-after-load 'diminish
           '(progn
              (diminish projectile (:eval (concat " " (projectile-project-name))))))))))
#+end_src

** :delight keyword
~:delight~ keyword provide frontend for delight ([[http://elpa.gnu.org/packages/delight.html][ELPA]], [[https://www.emacswiki.org/emacs/DelightedModes][Emacs wiki]]).

#+begin_src emacs-lisp
  (cort-deftest-with-macroexpand leaf/delight
    '(((leaf autorevert
         :delight t)
       (prog1 'autorevert
         (eval-after-load 'delight
           '(progn
              (delight 'autorevert)))))

      ((leaf autorevert
         :delight autorevert)
       (prog1 'autorevert
         (eval-after-load 'delight
           '(progn
              (delight 'autorevert)))))

      ((leaf autorevert
         :delight t
         :delight autorevert-polyfill)
       (prog1 'autorevert
         (eval-after-load 'delight
           '(progn
              (delight 'autorevert)
              (delight 'autorevert-polyfill)))))

      ((leaf autorevert
         :delight t autorevert-polyfill)
       (prog1 'autorevert
         (eval-after-load 'delight
           '(progn
              (delight 'autorevert)
              (delight 'autorevert-polyfill)))))

      ((leaf go-mode
         :delight " Go")
       (prog1 'go-mode
         (eval-after-load 'delight
           '(progn
              (delight 'go-mode " Go")))))

      ((leaf abbrev
         :delight (abbrev-mode " Abv"))
       (prog1 'abbrev
         (eval-after-load 'delight
           '(progn
              (delight 'abbrev-mode " Abv")))))

      ((leaf projectile
         :delight (projectile (:eval (concat " " (projectile-project-name)))))
       (prog1 'projectile
         (eval-after-load 'delight
           '(progn
              (delight 'projectile (:eval (concat " " (projectile-project-name))))))))

      ((leaf delight
         :delight ((abbrev-mode " Abv" "abbrev")
                   (smart-tab-mode " \\t" "smart-tab")
                   (eldoc-mode nil "eldoc")
                   (rainbow-mode)
                   (overwrite-mode " Ov" t)
                   (emacs-lisp-mode "Elisp" :major)))
       (prog1 'delight
         (eval-after-load 'delight
           '(progn
              (delight 'abbrev-mode " Abv" "abbrev")
              (delight 'smart-tab-mode " \\t" "smart-tab")
              (delight 'eldoc-mode nil "eldoc")
              (delight 'rainbow-mode)
              (delight 'overwrite-mode " Ov" t)
              (delight 'emacs-lisp-mode "Elisp" :major)))))))
#+end_src

* Information
** Donation
I love OSS and I am dreaming of working on it as *full-time* job.

*With your support*, I will be able to spend more time at OSS!

[[https://www.patreon.com/conao3][https://c5.patreon.com/external/logo/become_a_patron_button.png]]

** Community
All feedback and suggestions are welcome!

You can use github issues, but you can also use [[https://join.slack.com/t/conao3-support/shared_invite/enQtNTg2MTY0MjkzOTU0LTFjOTdhOTFiNTM2NmY5YTE5MTNlYzNiOTE2MTZlZWZkNDEzZmRhN2E0NjkwMWViZTZiYjA4MDUxYTUzNDZiNjY][Slack]]
if you want a more casual conversation.

** Contribution
We welcome PR!
Travis Cl test ~leaf-test.el~ with all Emacs version 24.4 or above.

I think that it is difficult to prepare the environment locally,
so I think that it is good to throw PR and test Travis for the time being!
Feel free throw PR!

*** Define new keywords
The following script is useful for adding keywords. This is a simplified ~leaf~ macro for ~*scratch*~.

You first design the list that the normalizer should return and define the keyword processor.
Then trial-and-error builds the normalizer by this script, and by typing ~C-M-x (eval-defun)~ at the beginning of ~defcustom~,
it can be overwrite variable and recognized by ~leaf~ (At that time the function to specify ~:set~ is executed.).

Once you have the S-expression expected from [[https://github.com/joddie/macrostep][macrostep]], let ~leaf-keywords-test.el~ define multiple tests
to ensure that they will execute correctly into the future.

#+begin_src emacs-lisp
  (let ((name 'leaf)
        (args '(;; << Your new leaf argument >>
                :combo (("="   . (" = " " == " " === " ))
                        ("=>"  . " => ")
                        ("C-a" . (back-to-indentation move-beginning-of-line beginning-of-buffer key-combo-return))
                        ("C-e" . (move-end-of-line end-of-buffer key-combo-return))))))

    ;; call `leaf'
    (let* ((leaf--autoload)
           ;; omit `leaf-append-defaults' to debug
           (args* (leaf-sort-values-plist
                   (leaf-normalize-plist args 'merge 'eval))))

      ;; call `leaf-process-keywords'
      (let ((name name) (plist args*) (raw args*))
        (let* ((leaf--name    name)
               (leaf--key     (pop plist))
               (leaf--keyname (substring (symbol-name leaf--key) 1))
               (leaf--value   (pop plist))
               (leaf--raw     raw)
               (leaf--rest    plist)
               (leaf--body))
          ;; renew (normalize) leaf--value, save follow expansion in leaf--body
          (setq leaf--value
                (cond

                 ;; << Your new normalizer >>
                 ((memq leaf--key '(:combo :combo*))
                  (let ((map (if (eq :combo leaf--key) 'global-map 'leaf-key-override-global-map))
                        (val) (fns))
                    (setq val (mapcan
                               (lambda (elm)
                                 (cond
                                  ((and (listp elm)
                                        (listp (car elm))
                                        (listp (caar elm)))
                                   (mapcan
                                    (lambda (el)
                                      (let ((emap  (and (symbolp (car el)) (car el)))   ; el's map
                                            (binds (if (leaf-pairp (car el)) el (cdr el))))
                                        (mapcar
                                         (lambda (el)
                                           (setq fns (append fns (if (listp (cdr el)) (cdr el) `(,(cdr el)))))
                                           `(,(or emap map) ,(car el) ,(if (stringp (cdr el)) (cdr el) `',(cdr el))))
                                         binds)))
                                    elm))
                                  ((listp elm)
                                   (let ((emap  (and (symbolp (car elm)) (car elm)))    ; elm's map
                                         (binds (if (leaf-pairp (car elm)) elm (cdr elm))))
                                     (mapcar
                                      (lambda (el)
                                        (setq fns (append fns (if (listp (cdr el)) (cdr el) `(,(cdr el)))))
                                        `(,(or emap map) ,(car el) ,(if (stringp (cdr el)) (cdr el) `',(cdr el))))
                                      binds)))))
                               leaf--value))
                    `(,val ,(delq nil (mapcar (lambda (elm) (when (symbolp elm) elm)) fns)))))))

          (pp `((:dummy)
                ========== leaf--value
                ,leaf--value
                (:dummy)
                ========== leaf--body
                (progn
                  ,@(eval (plist-get leaf-keywords leaf--key)))
                ))
          nil))))
#+end_src

Note: ~macrostep~ return ~function~ instead of #', replace it via follow regexp by ~C-M-% (query-replace-regexp)~.

#+begin_quote
(autoload
         (function \([^ ]*\))
         \([^ ]*\) → (autoload #'\1 \2
#+end_quote

** Migration
** License
#+begin_example
  Affero General Public License Version 3 (AGPLv3)
  Copyright (c) Naoya Yamashita - https://conao3.com
  https://github.com/conao3/leaf-keywords.el/blob/master/LICENSE
#+end_example

** Author
- Naoya Yamashita ([[https://github.com/conao3][conao3]])

** Contributors

** Special Thanks
Advice and comments given by [[http://emacs-jp.github.io/][Emacs-JP]]'s forum member has been a great help
in developing ~leaf-keywords.el~.

Thank you very much!!
